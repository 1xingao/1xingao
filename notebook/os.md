# 操作系统

[课程连接](https://www.bilibili.com/video/BV1YE411D7nH)

## 操作系统概述

### 操作系统的四个特征

1. 并发，两个或多个时间同一时间运行，*宏观上同时发生，微观上交替进行*
  
   > 并行指的是两个或多个同时进行（非特性）

2. 共享，系统的资源同时供给多个进程共同使用  
  
   - 互斥共享  *宏观上同时发生，微观上交替进行*
   
   - 同时共享  在同一个时间同一设备只能分配给一个进程使用
     
     > 并发和共享的关系 :    互为存在条件

3. 虚拟，把物理上的实体表内若干个逻辑上的对应物，前者是实际存在的，后者是用户感受到的  
   （时分复用技术和空分复用技术）
   
   > 如果失去了并发性，虚拟性也没有存在的意义

4. 异步，再多到程序环境下允许多个程序并发执行，由于资源优先，进程执行私一贯到底的
  
   > 只有系统拥有了并发性才会导致异步性

### 操作系统的分类

1. 手工操作阶段

2. 批处理操作阶段  （每有人机交互功能，一直等待到程序结束，相应时间长）
  
   - 单道批处理（引入脱机输入输出技术，并且监督程序负责控制作业的输入和输出）
   - 多道批处理（引入操作系统，中断技术，各个程序并发执行）

3. 分时操作系统  (计算机以时间片为单位轮流为各个用户服务，各个用户可以通过终端与计算机进行交互)

4. 实时操作系统
  
   - 硬实时操作系统（必须绝对严格规定时间内完成处理）
   - 软实时操作系统（能接受偶尔违反时间规定）
   - 可以优先相应紧急任务

5. 网络操作系统，分布式操作系统，个人计算机操作系统

### 操作系统的运行机制和体系结构

### 运行机制

1. 指令分为特权（不允许用户执行）指令和非特权指令

2. 处理器有两种状态（用户态和核心态），用户态只能窒息感非特权指令，核心态可以执行所有指令

3. 程序分为内核程序和应用程序（内核程序可以使用核心态）

### 操作系统内核

1. 操作系统中含有内核功能和非内核功能（内核是计算机的底层软件）
  
   > 大内核包括时钟管理、中断处理、原语（设备驱动、cpu切换）|  微内核不包括进程管理、存储器管理、设备管理

![1.1_4](https://cdn.jsdelivr.net/gh/1xingao/picgo@main/img/1.1_4.png)

### 中断和异常

1. 中断机制的诞生：实现多道程序并发执行，发生中断意味着需要操作系统介入管理工作

2. 中断发生时，cpu进入核心态，当前进程暂停运行，操作系统进行中断处理，对于不同的中断信号进行不同处理（进程切换，I/O设备）

> 有了中断才能实现多道程序并发执行
> 用户态->核心态只能通过中断，核心态->用户态执行特权执行，切换状态字（psw）完成

1. 中断的分类
  
   - 内中断（异常，例外，陷入）来源是cpu内部与当前执行的指令有关
     - 自愿中断（指令中断）
     - 强迫中断（硬件故障，软件中断）
   - 外中断（中断） 来源cpu外部
     - 外设请求（i/o设备完成）
     - 人工干预（用户强制终止进程）

2. 外中断的处理过程
  
   1. 每条指令执行结束后，cpu检查是否有外部中断信号
   2. 若有外部中断信号，则需要保护中断进程cpu环境
   3. 根据中断信号转入相应的中断处理程序
   4. 回退源程序的cpu环境退出中断，源程序继续执行

![1.5](https://cdn.jsdelivr.net/gh/1xingao/picgo@main/img/1.5.png)

### 系统调用

1. 命令接口和程序接口

2. 操作系统提供系统调用，用户只能使用系统调用发出计算机资源请求，操作系统会对各个请求协调管理，保证系统的稳定性和安全性

3. 系统调用分类
  
   - 设备管理
   - 文件管理
   - 进程控制
   - 进程通信
   - 内存管理

4. 系统调用只能在核心态下运行，系统调用属于内核功能

5. 涉及到调用系统资源的函数才是系统调用

6. 部分库函数本质就是封装好的系统调用

7. 系统调用会使处理去从用户态进入核心态

![1.1_6](https://cdn.jsdelivr.net/gh/1xingao/picgo@main/img/1.1_6.png)

---

## 进程

### 进程的组成

> 程序就是一个指令序列

1. 进程控制块（pcb）一种数据结构

2. 程序段，数据段，pcb三部分组成进程实体

3. pcb使进程存在的唯一标识
  
   1. 进程是程序一次执行过程
   
   2. 进程是一个程序及其数据在处理机上顺序执行所发生的的活动
   
   3. 进程是具有独立功能的程序在数据集合上的运行过程，他是系统纪念性资源分配和调度的一个独立单位

> 强调的是进程的动态性  
> 进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位

1. 程序段存放程序代码，数据段存放程序运行时使用，产生的运算数据，操作系统通过pcb来进行管理进程，存放操作系统用于进程管理的各种信息
  
   1. 进程描述信息
     
      - 进程标识符pid
      
      - 用户标识符uid
   
   2. 进程控制和管理信息
     
      - 进程当前状态
      
      - 进程优先级
   
   3. 资源分配清单
   
   4. 处理机相关信息
     
      - 各种寄存器值

### 进程的组织

> 讨论多个进程之间的组织方式问题

1. 链接方式
  
   - 按照进程状态将pcb分为多个队列
   - 操作系统持有指向各个队列的指针
     - 执行指针
     - 就绪队列指针
     - 阻塞队列指针（优先级高的在前面）

2. 索引方式
  
   - 根据进程状态不同建立索引表
   - 操作系统持有指向各个索引表的指针
     - 指针方式同链接方式

### 进程的特征

- 动态性，并发性，独立性，异步性，结构性

> 进程是资源分配，接受调度的基本单位

![2.1_1](https://cdn.jsdelivr.net/gh/1xingao/picgo@main/img/2.1_1.png)

### 进程的状态

1. 运行态

2. 就绪态

3. 阻塞态

4. 创建态

5. 撤销态

### 线程属性

![shuxing](https://cdn.jsdelivr.net/gh/1xingao/picgo@main/img/shuxing.jpg)

### 进程通信

![tongxin](https://cdn.jsdelivr.net/gh/1xingao/picgo@main/img/tongxin.jpg)

### 多线程模型

![duoxiancheng](https://cdn.jsdelivr.net/gh/1xingao/picgo@main/img/duoxiancheng.jpg)

### 进程控制

1. 对系统中的所有进程进行有效管理

2. 实现进程状态之间的转换

3. 原语执行期间不允许中断（特权指令）(特殊程序)
  
   - 关中断指令
   - 开中断指令

![2.1_2](https://cdn.jsdelivr.net/gh/1xingao/picgo@main/img/2.1_2.png)

### 处理机调度

1. 当有一堆任务要处理的时候，由于资源有限，无法同时处理，需要某种规则来处理这个任务的顺序

2. 高级调度(作业调度)：外存和内存之间的调度，作业调入创建pcb，调出撤销pcb，调入调出只有一个
  
   - 调度何时调入内存

3. 中级调度（内存调度），引入虚拟存储技术，可将不能运行的进程调至外存等待，等具备了运行条件后重新调入。（挂起状态）

4. 低级调度（进程调度）按照方法从就绪队列中选取一个进程分配处理机
- 挂起状态

![2.2](https://cdn.jsdelivr.net/gh/1xingao/picgo@main/img/1.2_4.png)

![2.2_1](https://cdn.jsdelivr.net/gh/1xingao/picgo@main/img/2.2_1.png)

### 进程调度

- 非抢占方式，只允许进程主动放弃处理机

- 抢占方式，当一个进程在处理及上执行时，如果有更紧急的进程使用处理机，立刻暂停当前进程，分配进程到更紧急的任务

- 狭义的进程调度指的是从就绪队列选择一个要运行的进程

- 广义的包括进程选择和进程切换

- 进程的切换过程
  
  1. 对原来运行的进程各种数据保存
  
  2. 回复新进程的数据

![2.1_3](https://cdn.jsdelivr.net/gh/1xingao/picgo@main/img/2.1_3.png)

### 调度算法的评价指标

- cpu利用率，利用率 = 忙碌时间 / 总时间

- 系统吞吐量，单位时间内完成作业的数量，系统吞吐量 = 总作业数量 / 完成时间

- 周转时间，作业被提交到完成的时间间隔，周转时间 = 作业完成时间 - 作业提交时间

> 周转时间包括作业在外存后背队列上等待作业调度时间+进程在就绪队列等待时间（低级调度） + 进程在cpu上的执行时间 + 进程等待i/o完成的时间

- 平均周转时间，各个作业周转时间之和 / 作业数

- 带权周转时间，作业周转使劲按 / 作业实际运行时间

- 等待时间，进程处于等待时间之和，等待i/o的时间不算等待时间，在外存等待时间也算

- 响应时间，从用户提交请求到首次产生响应的时间

### 调度算法

1. 先来先服务（fcfs）
  
   - 按照作业到达的顺序进行服务
   
   - 用于作业调度的时候考虑那个作业先到达后背队列，用于进程调度时，考虑那个进程先到达就绪队列
   
   - 非抢占式算法
   
   - 优先，公平，算法实现简单
   
   - 缺点，带权周转时间长的等待时间过长，对长作业有利，对短作业不利
   
   - 是否会导致饥饿，不会

2. 短作业优先（sjf)
  
   - 最短作业/进程优先得到服务（运行时间短优先）
   
   - 可用于作业调度，也可以用于进程调度，用于进程调度时称为“短进程优先算法”（spf）
   
   - 非抢占式算法，但有抢占式算法版本----最短剩余时间优先算法（srtn）
   
   - srtn，每当有进程加入就绪队列时，会引起就绪队列改变
   
   - “最短的”平均等待时间，平均周转时间
   
   - 不公平，对短作业有利，长作业有可能导致饥饿

3. 高响应比优先算法（hrrn）
  
   - 每次cpu空闲时计算响应比，响应比大的先分配
   
   - 响应比，（等待时间+要求服务使劲按） /要求服务时间
   
   - 可以进程调度，也可以作业调度
   
   - 非抢占式
   
   - 综合考虑等待时间和运行时间，集合前两种优点
   
   - 不会导致饥饿
     
     ***以上算法适用于批处理系统***
     
     ![2.2_4](https://cdn.jsdelivr.net/gh/1xingao/picgo@main/img/2.2_4.png)

4. 时间片轮转调度算法（RR）
  
   - 公平轮流的为各个进程服务
   
   - 按照各个进程到达就绪队列的顺序，轮流让各个进程执行一个时间片，执行完回到就绪队列队尾
   
   - 用于进程调度
   
   - 抢占式算法，由时钟装置发出时钟中断来通知cpu时间片到了
   
   - 如果时间片太大，使每个车光绪都可以在一个时间片内完成，则会退回化成先来先服务调度算法
   
   - 时间片太小会导致进程切换频繁，系统会花费大量时间处理进程切换
   
   - 响应快，适用于分时操作系统，公平
   
   - 高频率的进程切换具有一定开销，不区分紧急程度
   
   - 不会导致饥饿

5. 优先级调度算法
  
   - 为每一个进程/作业设置一个优先级，调度时选择优先级最高的
   
   - 可用于进程调度，也可以用于作业调度，也会使用在i/o调度上
   
   - 有抢占式，也有非抢占式
   
   - 就绪队列不是只有一个，可以动态调整就绪队列也可以有多个不同优先级的队列
   
   - 根据偶县级是否可以动态改变分为，动态优先级和静态优先级
   
   - 设置优先级
     
     - 系统进程优先级高于用户进程
     
     - 前台进程优先级高于后台进程
     
     - 操作系统更偏好i/o型进程（i/o繁忙型进程）（优先让i/o设备投入工作会提高资源利用率）
       
       > 与之相对的叫做计算型进程（cpu繁忙型进程）
     
     - 动态优先级的时候什么时候调整优先级
       
       - 如果一个进程等待了很久会优先
       
       - 如果进程运行了很久会降低优先级
       
       - 频繁进行i/o操作优先级提高
   
   - 用于优先级区分紧急程度，适用于实时操作系统
   
   - 会发生饥饿（频繁有高优先级进程到达）

6. 多级反馈队列调度算法
  
   - 对其他调度算法折中权衡
   
   - 抢占式算法
   
   - 算法细节
     
     - 设置多级就绪队列，各级队列优先级从高到低，时间片从小到大
     
     - 新机场南横到达先进入一级队列，若用完时间片为结束进程则会进入下一级队尾
     
     - 只有k级队列为空，才会为k+1队列头分配时间片
     
     - 当到达一个优先级更高的进程，运行态进程会回到原队列队尾而不是下一级队列
     
     - 如果进程已经在最低级队列时，完成时间片返回低级队列
   
   - 每个新到达的进程可以快速得到相应，算进程可以在较少时间完成，可以灵活调整对各类i昵称的偏好程度（i/o进程运行后回到原队列）
   
   - 可能会导致饥饿

![2.2_5](https://cdn.jsdelivr.net/gh/1xingao/picgo@main/img/2.2_5.png)

***适用于交互式系统***

### 进程同步

- 讨论解决进程异步的问题

- 同步也称为直接制约关系，未完成某种任务而建立的两个或者多个进程，这些基础南横因需要在某些位置上协调工作次序而产生的制约关系

### 进程互斥

1. 把一个时间段内只允许一个进程使用的资源的称为临界资源

2. 对于临界资源的访问，必须互斥进行

3. 对于临界资源的互斥访问
  
   - 进入区（检查是否可以进入临界区），可以进入则会设置正在访问资源的标志（上锁）
   
   - 临界区，访问资源的代码
   
   - 退出区，解除正在访问资源标志（解锁）
   
   - 剩余区，其他处理
   
   - 为了保证系统的整体性能应该遵顼一下规则
     
     - 空闲让进
     
     - 忙则等待
     
     - 有限等待，保证有限时间内进入临界区，不会导致饥饿
     
     - 让权等待，当进程不能进入临界区，应该放弃处理机。防止进程忙等待

![2.2_6](https://cdn.jsdelivr.net/gh/1xingao/picgo@main/img/2.2_6.png)

### 进程互斥的实现方法

![ruanjian](https://cdn.jsdelivr.net/gh/1xingao/picgo@main/img/jinchengruanjian.jpg)

![yingjian](https://cdn.jsdelivr.net/gh/1xingao/picgo@main/img/jinchengyingjian.jpg)

### 信号量机制

1. 之前的互斥的实现方法都无法实现让权等待，部分在进入区和临界区之间无法一气呵成  
   进程调度会改变

2. 信号就是一个变量，可以用一个信号量表示系统中某种资源的数量

3. 原语，特殊程序段，执行只能一气呵成，本次使用的是wait和signal原语或者叫P，V

#### 整形信号量

1. 用一个整型变量作为信号量，表示当前系统中某种资源数量

2. 与普通变量区别是信号量只能进行初始化，P，V
  
```cpp
   int s = 1;
   
   void wait(int s){
       while(s<=0);
       s = s-1;
   }
   
   void signal(int s){
       s= s+1;
   }
   
   //进程p0
   wait(s);//进入区
   //使用打印机资源//临界区
   signal(s);//退出区
```
3. 其他进程执行while循环会导致忙等，整型信号量机制不满足让权等待

#### 记录型信号量


```cpp
typedef struct{
    int value;//剩余资源数
    struct process *l;//等待队列
}semaphore;

void wait(semaphore s){
    s.value--;
    if(s.value< 0){
        block(s.l);
    }
}

void signal(semaphore s){
    s.value++;
    if(s.value <=0){
        wakeup(s.l);
    }
}
```


1. block原语，当剩余资源不够的时候会使运行态的进入阻塞态，并且挂到信号量s的等待队列中

2. wakeup原语，释放资源后若还有其他进程等待资源，则会使用wakeup唤醒等待队列的一个进程，从阻塞到就绪队列

![2.3_4](https://cdn.jsdelivr.net/gh/1xingao/picgo@main/img/2.3_4.png)

### 信号量机制实现进程互斥

1. 分析并发进程的关键活动，划定临界区

2. 设置互斥信号量mutex，初始值为1

3. 临界区之前执行P(mutex)

4. 临界区后执行V(nutex)

5. 对于不同的临界i资源需要设置不同的互斥信号量

6. pv操作成对存在

### 信号量机制实现进程同步

> 进程同步保证各个进程有顺序的执行

1. 分析什么地方需要实现同步关系，确定一前一后关系

2. 设置同步信号量是，初始值为零

3. 在前操作之后执行V

4. 在后操作之前执行P

5. 同步信号量初始值为零

### 信号量机制实现前驱关系

![2.3_5](https://cdn.jsdelivr.net/gh/1xingao/picgo@main/img/2.3_5.png)

> 实现互斥在实现同步之后，不然会导致死锁
> 临界资源等于一的时候可以不设置互斥信号量

#### 读写问题的互斥和同步

使用计数器变量来表示当前访问的进程数量实现同时读取文件

![2.3_9](https://fastly.jsdelivr.net/gh/1xingao/picgo@main/img/16622797175991662279717207.png)

但是如果有源源不断的读进程进入的时候会导致写进程饿死

新加一个互斥信号量用于实现写优先

![2.3_9_2](https://fastly.jsdelivr.net/gh/1xingao/picgo@main/img/16622798996001662279898946.png)

#### 哲学家进餐问题

一个进程同时需要两个以上的临界资源访问

![2.3_10](https://fastly.jsdelivr.net/gh/1xingao/picgo@main/img/16622808266001662280825872.png)

### 管程

> 一种高级同步机制

#### 管程是一种特殊的软件模块，有这些组成

1. 局部于广成的共享数据结构说明
2. 对该数据结构进行操作的过程（函数）
3. 对局部于管程的共享数据设置初始值的语句
4. 管程有一个名字

#### 管程的基本特征

1. 局部与管程的数据只能被局部于管程的过程访问
2. 一个进程只有通过调用管程内的过程才能进入管程访问共享数据
3. 每次仅允许一个进程在管程内执行某个内部过程

#### 管程的实现
![2.3_11](https://fastly.jsdelivr.net/gh/1xingao/picgo@main/img/16622817767011662281776649.png
)

### 死锁

死锁： 在并发环境下，个进程因为竞争资源造成的一种互相等待对方手里资源，导致各个进程都在阻塞，无法向前推进的现象

饥饿 ： 由于长时间得不到自己想要的资源，某进程无法向前推进的xianx

#### **死锁产生的条件**

1. 互斥条件，存在互斥访问的资源争抢
2. 不可剥夺条件：在没有使用完，别人不能被其他进程强行抢走，只能主动释放
3. 请求和保持条件：已经持有一个资源，但又提出了新的资源请求
4. 循环等待资源条件： 存在一个进程的资源循环等待链

#### **什么时候会发生死锁**

1. 对系统资源的竞争
2. 进程推进顺序非法
3. 信号量使用不当

####  **死锁的处理策略**

1. 预防死锁
2. 避免死锁，使用一个算法防止系统进入死锁
3. 死锁的检测于解除

#### **预防死锁**

破坏死锁产生的四个条件

1. 互斥条件（对于必须互斥使用的资源的争抢） 将独占设备改造成**逻辑**上的共享设备（spooling技术）
2. 破坏不剥夺条件  
方案一：当一个进程请求的资源得不到满足时，必须先释放现有资源  
方案二：操作系统吸住强行剥夺

3. 破坏请求和保持条件，采用静态分配方式，在一个进程运行前一次申请完所需要的全部资源
4. 破坏循环等待他条件，顺序资源分配法，对于每一个资源编号，进程必须按照编号递增的顺序请求资源。

![2.4_2](https://fastly.jsdelivr.net/gh/1xingao/picgo@main/img/16624467037061662446702911.png)

#### 避免死锁

安全序列：如果系统按照序列分配资源，则每个进程都能顺利完成。只要找出一个安全序列，系统就是安全序列。

不安全状态： 系统找不到任何一个安全序列。（可能会发生死锁）

**银行家算法** ： 每次进程提出资源申请，咸鱼盘这次分配会不会导致系统进入不安全状态，如果进入不安全状态，就暂时不分配资源

![2.4_3](https://fastly.jsdelivr.net/gh/1xingao/picgo@main/img/16624475607051662447560338.png)

#### 死锁的检测和解除

![2.4_4](https://fastly.jsdelivr.net/gh/1xingao/picgo@main/img/16625499681321662549967253.png)

定义一种数据结构

1. 有向图，分为两种节点，一种进程节点，一种资源节点，资源节点显示有多少个同类资源
2. 进程节点指向资源节点代表请求多少个资源，资源节点指向进程节点表示分配给进程多少个节点
3. 死锁检测算法类似安全序列不断化简图，如果每个进程节点都可以被化简为孤点，则没有死锁
4. 化简完后还连着边的进程就是死锁进程

**死锁的解除**

1. 资源剥夺法，挂起某些死锁进程释放他所占有的资源
2. 撤销进程法，强制关闭某些死锁进程（危险方法）
3. 进程回退法，让一个或者多个进程回退到足以避免死锁的状态，要求系统记录进程的历史信息，设置还原点（难以实现）

## 内存管理

### 内存概念和作用

1. 内存适用于存放数据的硬件，执行程序前需要先放到内存中才能被cpu处理
2. 