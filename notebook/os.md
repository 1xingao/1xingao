# 操作系统

[课程连接](https://www.bilibili.com/video/BV1YE411D7nH)

## 操作系统概述

### 操作系统的四个特征

1. 并发，两个或多个时间同一时间运行，*宏观上同时发生，微观上交替进行*

    >并行指的是两个或多个同时进行（非特性）

1. 共享，系统的资源同时供给多个进程共同使用  
    - 互斥共享  *宏观上同时发生，微观上交替进行*

    - 同时共享  在同一个时间同一设备只能分配给一个进程使用

    >并发和共享的关系 :    互为存在条件

1. 虚拟，把物理上的实体表内若干个逻辑上的对应物，前者是实际存在的，后者是用户感受到的  
（时分复用技术和空分复用技术）
    >如果失去了并发性，虚拟性也没有存在的意义

1. 异步，再多到程序环境下允许多个程序并发执行，由于资源优先，进程执行私一贯到底的
    >只有系统拥有了并发性才会导致异步性

### 操作系统的分类

1. 手工操作阶段

2. 批处理操作阶段  （每有人机交互功能，一直等待到程序结束，相应时间长）
    - 单道批处理（引入脱机输入输出技术，并且监督程序负责控制作业的输入和输出）
    - 多道批处理（引入操作系统，中断技术，各个程序并发执行）

3. 分时操作系统  (计算机以时间片为单位轮流为各个用户服务，各个用户可以通过终端与计算机进行交互)

4. 实时操作系统
    - 硬实时操作系统（必须绝对严格规定时间内完成处理）
    - 软实时操作系统（能接受偶尔违反时间规定）
    - 可以优先相应紧急任务

5. 网络操作系统，分布式操作系统，个人计算机操作系统

### 操作系统的运行机制和体系结构

### 运行机制

1. 指令分为特权（不允许用户执行）指令和非特权指令

1. 处理器有两种状态（用户态和核心态），用户态只能窒息感非特权指令，核心态可以执行所有指令

1. 程序分为内核程序和应用程序（内核程序可以使用核心态）

### 操作系统内核

1. 操作系统中含有内核功能和非内核功能（内核是计算机的底层软件）

    > 大内核包括时钟管理、中断处理、原语（设备驱动、cpu切换）|  微内核不包括进程管理、存储器管理、设备管理

![1.1_4](https://cdn.jsdelivr.net/gh/1xingao/picgo@main/img/1.1_4.png)

### 中断和异常

1. 中断机制的诞生：实现多道程序并发执行，发生中断意味着需要操作系统介入管理工作

1. 中断发生时，cpu进入核心态，当前进程暂停运行，操作系统进行中断处理，对于不同的中断信号进行不同处理（进程切换，I/O设备）

>有了中断才能实现多道程序并发执行
> 用户态->核心态只能通过中断，核心态->用户态执行特权执行，切换状态字（psw）完成

1. 中断的分类
    - 内中断（异常，例外，陷入）来源是cpu内部与当前执行的指令有关
        - 自愿中断（指令中断）
        - 强迫中断（硬件故障，软件中断）
    - 外中断（中断） 来源cpu外部
        - 外设请求（i/o设备完成）
        - 人工干预（用户强制终止进程）

1. 外中断的处理过程
    1. 每条指令执行结束后，cpu检查是否有外部中断信号
    1. 若有外部中断信号，则需要保护中断进程cpu环境
    1. 根据中断信号转入相应的中断处理程序
    1. 回退源程序的cpu环境退出中断，源程序继续执行

![1.5](https://cdn.jsdelivr.net/gh/1xingao/picgo@main/img/1.5.png)

### 系统调用

1. 命令接口和程序接口

1. 操作系统提供系统调用，用户只能使用系统调用发出计算机资源请求，操作系统会对各个请求协调管理，保证系统的稳定性和安全性

1. 系统调用分类
    - 设备管理
    - 文件管理
    - 进程控制
    - 进程通信
    - 内存管理

1. 系统调用只能在核心态下运行，系统调用属于内核功能

1. 涉及到调用系统资源的函数才是系统调用

1. 部分库函数本质就是封装好的系统调用

1. 系统调用会使处理去从用户态进入核心态

![1.1_6](https://cdn.jsdelivr.net/gh/1xingao/picgo@main/img/1.1_6.png)

---

## 进程

### 进程的组成

>程序就是一个指令序列

1. 进程控制块（pcb）一种数据结构

1. 程序段，数据段，pcb三部分组成进程实体

1. pcb使进程存在的唯一标识
    1. 进程是程序一次执行过程

    1. 进程是一个程序及其数据在处理机上顺序执行所发生的的活动

    1. 进程是具有独立功能的程序在数据集合上的运行过程，他是系统纪念性资源分配和调度的一个独立单位

>强调的是进程的动态性  
>进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位

1. 程序段存放程序代码，数据段存放程序运行时使用，产生的运算数据，操作系统通过pcb来进行管理进程，存放操作系统用于进程管理的各种信息
    1. 进程描述信息

        - 进程标识符pid

        - 用户标识符uid

    1. 进程控制和管理信息

        - 进程当前状态

        - 进程优先级

    1. 资源分配清单

    1. 处理机相关信息

        - 各种寄存器值

### 进程的组织

>讨论多个进程之间的组织方式问题

1. 链接方式
    - 按照进程状态将pcb分为多个队列
    - 操作系统持有指向各个队列的指针
        - 执行指针
        - 就绪队列指针
        - 阻塞队列指针（优先级高的在前面）

1. 索引方式
    - 根据进程状态不同建立索引表
    - 操作系统持有指向各个索引表的指针
        - 指针方式同链接方式

### 进程的特征

- 动态性，并发性，独立性，异步性，结构性

>进程是资源分配，接受调度的基本单位

![2.1_1](https://cdn.jsdelivr.net/gh/1xingao/picgo@main/img/2.1_1.png)

### 进程的状态

1. 运行态

1. 就绪态

1. 阻塞态

1. 创建态

1. 撤销态

### 进程属性

![shuxing](https://cdn.jsdelivr.net/gh/1xingao/picgo@main/img/shuxing.jpg)

### 进程通信

![tongxin](https://cdn.jsdelivr.net/gh/1xingao/picgo@main/img/tongxin.jpg)

### 多线程模型

![duoxiancheng](https://cdn.jsdelivr.net/gh/1xingao/picgo@main/img/duoxiancheng.jpg)

### 进程控制

1. 对系统中的所有进程进行有效管理

1. 实现进程状态之间的转换

1. 原语执行期间不允许中断（特权指令）(特殊程序)
    - 关中断指令
    - 开中断指令

![2.1_2](https://cdn.jsdelivr.net/gh/1xingao/picgo@main/img/2.1_2.png)

### 处理机调度

1. 当有一堆任务要处理的时候，由于资源有限，无法同时处理，需要某种规则来处理这个任务的顺序

1. 高级调度(作业调度)：外存和内存之间的调度，作业调入创建pcb，调出撤销pcb，调入调出只有一个
    - 调度何时调入内存

1. 中级调度（内存调度），引入虚拟存储技术，可将不能运行的进程调至外存等待，等具备了运行条件后重新调入。（挂起状态）

1. 低级调度（进程调度）按照方法从就绪队列中选取一个进程分配处理机

- 挂起状态

![2.2](https://cdn.jsdelivr.net/gh/1xingao/picgo@main/img/1.2_4.png)

![2.2_1](https://cdn.jsdelivr.net/gh/1xingao/picgo@main/img/2.2_1.png)

### 进程调度

- 非抢占方式，只允许进程主动放弃处理机

- 抢占方式，当一个进程在处理及上执行时，如果有更紧急的进程使用处理机，立刻暂停当前进程，分配进程到更紧急的任务

- 狭义的进程调度指的是从就绪队列选择一个要运行的进程

- 广义的包括进程选择和进程切换

- 进程的切换过程

    1. 对原来运行的进程各种数据保存

    1. 回复新进程的数据

![2.1_3](https://cdn.jsdelivr.net/gh/1xingao/picgo@main/img/2.1_3.png)

### 调度算法的评价指标

- cpu利用率，利用率 = 忙碌时间 / 总时间

- 系统吞吐量，单位时间内完成作业的数量，系统吞吐量 = 总作业数量 / 完成时间

- 周转时间，作业被提交到完成的时间间隔，周转时间 = 作业完成时间 - 作业提交时间

>周转时间包括作业在外存后背队列上等待作业调度时间+进程在就绪队列等待时间（低级调度） + 进程在cpu上的执行时间 + 进程等待i/o完成的时间

- 平均周转时间，各个作业周转时间之和 / 作业数

- 带权周转时间，作业周转使劲按 / 作业实际运行时间

- 等待时间，进程处于等待时间之和，等待i/o的时间不算等待时间，在外存等待时间也算

- 响应时间，从用户提交请求到首次产生响应的时间

### 调度算法

1. 先来先服务（fcfs）

    - 按照作业到达的顺序进行服务

    - 用于作业调度的时候考虑那个作业先到达后背队列，用于进程调度时，考虑那个进程先到达就绪队列

    - 非抢占式算法

    - 优先，公平，算法实现简单

    - 缺点，带权周转时间长的等待时间过长，对长作业有利，对短作业不利

    - 是否会导致饥饿，不会

1. 短作业优先（sjf)

    - 最短作业/进程优先得到服务（运行时间短优先）

    - 可用于作业调度，也可以用于进程调度，用于进程调度时称为“短进程优先算法”（spf）

    - 非抢占式算法，但有抢占式算法版本----最短剩余时间优先算法（srtn）

    - srtn，每当有进程加入就绪队列时，会引起就绪队列改变

    - “最短的”平均等待时间，平均周转时间

    - 不公平，对短作业有利，长作业有可能导致饥饿

1. 高响应比优先算法（hrrn）

    - 每次cpu空闲时计算响应比，响应比大的先分配

    - 响应比，（等待时间+要求服务使劲按） /要求服务时间

    - 可以进程调度，也可以作业调度

    - 非抢占式

    - 综合考虑等待时间和运行时间，集合前两种优点

    - 不会导致饥饿

    ***以上算法适用于批处理系统***

    ![2.2_4](https://cdn.jsdelivr.net/gh/1xingao/picgo@main/img/2.2_4.png)

1. 时间片轮转调度算法（RR）

    - 公平轮流的为各个进程服务

    - 按照各个进程到达就绪队列的顺序，轮流让各个进程执行一个时间片，执行完回到就绪队列队尾

    - 用于进程调度

    - 抢占式算法，由时钟装置发出时钟中断来通知cpu时间片到了

    - 如果时间片太大，使每个车光绪都可以在一个时间片内完成，则会退回化成先来先服务调度算法

    - 时间片太小会导致进程切换频繁，系统会花费大量时间处理进程切换

    - 响应快，适用于分时操作系统，公平

    - 高频率的进程切换具有一定开销，不区分紧急程度

    - 不会导致饥饿

1. 优先级调度算法

    - 为每一个进程/作业设置一个优先级，调度时选择优先级最高的

    - 可用于进程调度，也可以用于作业调度，也会使用在i/o调度上

    - 有抢占式，也有非抢占式

    - 就绪队列不是只有一个，可以动态调整就绪队列也可以有多个不同优先级的队列

    - 根据偶县级是否可以动态改变分为，动态优先级和静态优先级

    - 设置优先级

        - 系统进程优先级高于用户进程

        - 前台进程优先级高于后台进程

        - 操作系统更偏好i/o型进程（i/o繁忙型进程）（优先让i/o设备投入工作会提高资源利用率）

        >与之相对的叫做计算型进程（cpu繁忙型进程）

        - 动态优先级的时候什么时候调整优先级

            - 如果一个进程等待了很久会优先

            - 如果进程运行了很久会降低优先级

            - 频繁进行i/o操作优先级提高

    - 用于优先级区分紧急程度，适用于实时操作系统

    - 会发生饥饿（频繁有高优先级进程到达）

1. 多级反馈队列调度算法

    - 对其他调度算法折中权衡

    - 抢占式算法

    - 算法细节

        - 设置多级就绪队列，各级队列优先级从高到低，时间片从小到大

        - 新机场南横到达先进入一级队列，若用完时间片为结束进程则会进入下一级队尾

        - 只有k级队列为空，才会为k+1队列头分配时间片

        - 当到达一个优先级更高的进程，运行态进程会回到原队列队尾而不是下一级队列

        - 如果进程已经在最低级队列时，完成时间片返回低级队列

    - 每个新到达的进程可以快速得到相应，算进程可以在较少时间完成，可以灵活调整对各类i昵称的偏好程度（i/o进程运行后回到原队列）

    - 可能会导致饥饿

![2.2_5](https://cdn.jsdelivr.net/gh/1xingao/picgo@main/img/2.2_5.png)

***适用于交互式系统***

### 进程同步

- 讨论解决进程异步的问题

- 同步也称为直接制约关系，未完成某种任务而建立的两个或者多个进程，这些基础南横因需要在某些位置上协调工作次序而产生的制约关系

### 进程互斥

1. 把一个时间段内只允许一个进程使用的资源的称为临界资源

1. 对于临界资源的访问，必须互斥进行

1. 对于临界资源的互斥访问

    - 进入区（检查是否可以进入临界区），可以进入则会设置正在访问资源的标志（上锁）

    - 临界区，访问资源的代码

    - 退出区，解除正在访问资源标志（解锁）

    - 剩余区，其他处理
  
    - 为了保证系统的整体性能应该遵顼一下规则

        - 空闲让进

        - 忙则等待

        - 有限等待，保证有限时间内进入临界区，不会导致饥饿

        - 让权等待，当进程不能进入临界区，应该放弃处理机。防止进程忙等待

![2.2_6](https://cdn.jsdelivr.net/gh/1xingao/picgo@main/img/2.2_6.png)

### 进程互斥的实现方法

![ruanjian](https://cdn.jsdelivr.net/gh/1xingao/picgo@main/img/jinchengruanjian.jpg)

![yingjian](https://cdn.jsdelivr.net/gh/1xingao/picgo@main/img/jinchengyingjian.jpg)

### 信号量机制

1. 之前的互斥的实现方法都无法实现让权等待，部分在进入区和临界区之间无法一气呵成  
进程调度会改变

1. 信号就是一个变量，可以用一个信号量表示系统中某种资源的数量

1. 原语，特殊程序段，执行只能一气呵成，本次使用的是wait和signal原语或者叫P，V

#### 整形信号量

1. 用一个整型变量作为信号量，表示当前系统中某种资源数量

1. 与普通变量区别是信号量只能进行初始化，P，V

        int s = 1;

        void wait(int s){
            while(s<=0);
            s = s-1;
        }
        void signal(int s){
            s= s+1;
        }
        进程p0
        wait(s);//进入区
        使用打印机资源//临界区
        signal(s);//退出区

1. 其他进程执行while循环会导致忙等，整型信号量机制不满足让权等待

#### 记录型信号量

        typedef struct{
            int value;//剩余资源数
            struct process *l;//等待队列
        }semaphore;

        void wait(semaphore s){
            s.value--;
            if(s.value< 0){
                block(s.l);
            }
        }

        void signal(semaphore s){
            s.value++;
            if(s.value <=0){
                wakeup(s.l);
            }
        }

1. block原语，当剩余资源不够的时候会使运行态的进入阻塞态，并且挂到信号量s的等待队列中

1. wakeup原语，释放资源后若还有其他进程等待资源，则会使用wakeup唤醒等待队列的一个进程，从阻塞到就绪队列

![2.3_4](https://cdn.jsdelivr.net/gh/1xingao/picgo@main/img/2.3_4.png)

### 信号量机制实现进程互斥

1. 分析并发进程的关键活动，划定临界区

1. 设置互斥信号量mutex，初始值为1

1. 临界区之前执行P(mutex)

1. 临界区后执行V(nutex)

1. 对于不同的临界i资源需要设置不同的互斥信号量

1. pv操作成对存在

### 信号量机制实现进程同步

1. 分析什么地方需要实现同步关系，确定一前一后关系

1. 设置同步信号量是，初始值为零

1. 在前操作之后执行V

1. 在后操作之前执行P

### 信号量机制实现前驱关系

![2.3_5](https://cdn.jsdelivr.net/gh/1xingao/picgo@main/img/2.3_5.png)

>实现互斥在实现同步之后，不然会导致死锁
>临界资源等于一的时候可以不设置互斥信号量
